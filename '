#include "ipc_buffer.h"

#include <atomic>
#include <stdatomic.h>
#include <stdio.h>
#include <stdlib.h>

// Конфигурацция размера буфера + вырвнивание по размеру пейджей mmap
// если не влезаем в конец: 2 случая header влезает в конец - пишем его, если
// хедер не влезает, то полностью переносим. чтобы отличать
// если размер маленький лучше использовать цикл, а не memcopy

enum Flag {
  FLAG_NOT_READY = 0,
  FLAG_READY = 1,
  FLAG_ONLY_HEADER = 2,
  FLAG_ON_START = 3
};

typedef struct IpcBufferHeader {
  _Atomic uint64_t head;
  _Atomic uint64_t tail;
  uint64_t data_size;
} IpcBufferHeader;

typedef struct IpcBuffer {
  uint64_t data_size;

  // mmaped segment
  IpcBufferHeader *header;
  uint8_t *memory;
} IpcBuffer;

typedef struct EntryHeader {
  _Atomic int8_t flag;
  uint64_t seq;
  uint32_t payload_size;
} EntryHeader;

IpcBuffer *ipc_buffer_attach(uint8_t *mem, const uint64_t size) {
  IpcBuffer *buffer = malloc(sizeof(IpcBuffer));
  if (buffer == NULL) {
    perror("ipc_buffer_attach: malloc is failed");
    exit(EXIT_FAILURE);
  }

  buffer->data_size = size - sizeof(IpcBufferHeader);
  buffer->header = (IpcBufferHeader *)mem;
  buffer->memory = (mem + sizeof(IpcBufferHeader));

  return buffer;
}

IpcStatus ipc_buffer_init(IpcBuffer *buffer) {
  buffer->header->data_size = buffer->data_size;
  buffer->header->head = 0;
  atomic_store_explicit(&buffer->header->tail, 0, memory_order_release);

  return IPC_OK;
}

char ipc_write(IpcBuffer *buffer, const void *data, const uint64_t size) {
  const uint64_t full_entry_size = sizeof(EntryHeader) + size;
  const uint64_t buffer_size = buffer->header->data_size;
  if (full_entry_size > buffer_size) {
    perror("ipc_write: too large entry");
    exit(EXIT_FAILURE);
  }

  uint64_t head;
  uint64_t tail;
  uint64_t new_head;
  do {
    head = atomic_load_explicit(&buffer->header->head, memory_order_acquire);
    tail = atomic_load_explicit(&buffer->header->tail, memory_order_acquire);

    const uint64_t absolute_head = head & (buffer_size - 1);
    const uint64_t absolute_tail = tail & (buffer_size - 1);

    const uint64_t free_space = absolute_head > absolute_tail
                                    ? absolute_head - absolute_tail
                                    : absolute_tail - absolute_head;
    if (free_space < buffer_size) {
      return 0;
    }

  } while (!atomic_compare_exchange_strong_explicit())
}

IpcEntry ipc_read(IpcBuffer *, IpcReadMode);
